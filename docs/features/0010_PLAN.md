# Feature 0010: Real-Time Document Upload Progress with Stage Transparency

## Overview

Enhance the document upload progress display to provide real-time transparency about processing stages (text extraction, entity extraction, relationship building, finalization) using the existing SSE streaming architecture. Users will see detailed stage progress for each uploaded file without adding new complex dependencies.

## Technical Approach

Reuse the existing Server-Sent Events (SSE) pattern from `/chat/message/stream` to create a new `/documents/upload/stream` endpoint that emits progress events during document processing. Map technical processing phases to user-friendly stage messages and persist progress state in DocumentRegistry for navigation resilience.

---

## Backend Changes

### 1. Add Progress Event Types

**File:** `backend/api/schemas/documents.py`

Add new Pydantic schemas for progress streaming:

- `DocumentProgressStage` enum: `"initializing"`, `"reading"`, `"understanding"`, `"building_connections"`, `"finalizing"`, `"completed"`, `"failed"`
- `DocumentProgressEvent` schema with fields:
  - `filename: str`
  - `document_id: Optional[str]`
  - `stage: DocumentProgressStage`
  - `message: str` (user-friendly message)
  - `progress_percent: int` (0-100)
  - `timestamp: str`
  - `error: Optional[str]`
- `BatchProgressEvent` schema with fields:
  - `total_files: int`
  - `current_file_index: int`
  - `file_progress: DocumentProgressEvent`
  - `overall_progress_percent: int`

### 2. Progress Callback System

**File:** `backend/domain/documents/service.py`

Modify `process_document()` method signature to accept optional progress callback:

```python
async def process_document(
    self,
    document_id: str,
    extracted_content: str,
    processing_time: float,
    ocr_applied: bool = False,
    progress_callback: Optional[Callable[[str, int], Awaitable[None]]] = None
) -> Document:
```

Add progress emission points:
1. Before text processing: emit "reading" stage (25%)
2. Before `RAGEngine.insert()`: emit "understanding" stage (50%)
3. During RAG insertion (hook into LightRAG phases): emit "building_connections" (75%)
4. After successful completion: emit "finalizing" (90%)
5. Final update: emit "completed" (100%)

Update `processing_info` dict stored in registry to include `current_stage` field.

### 3. DocumentRegistry Stage Persistence

**File:** `backend/infrastructure/storage/document_registry.py`

Add new method:

```python
async def update_processing_stage(
    self,
    document_id: str,
    stage: str,
    progress_percent: int,
    message: str
) -> bool:
```

Stores current processing stage in document metadata so users can navigate away and return to see status.

Extend existing `update_status()` to accept optional `processing_stage` dict with:
- `stage: str`
- `progress_percent: int`
- `message: str`
- `timestamp: str`

### 4. SSE Streaming Endpoint

**File:** `backend/api/routes/documents.py`

Create new endpoint:

```python
@router.post("/upload/stream")
async def upload_documents_stream(
    files: List[UploadFile] = File(...),
    service: DocumentService = Depends(get_document_service),
    ocr_service: Optional[OCRService] = Depends(get_ocr_service)
):
```

Implementation:
- Use `StreamingResponse` with `media_type="text/event-stream"`
- Create async generator `generate_progress_stream()` 
- For each file in batch:
  1. Emit initializing event
  2. Call `upload_document()` 
  3. Call `DocumentProcessor.extract_text()` with progress callback that emits "reading" events
  4. Call `service.process_document()` with progress callback that emits stage events
  5. Emit completion or failure event
- Format events as SSE: `data: {json}\n\n`
- Follow same pattern as `/chat/message/stream` endpoint (lines 77-125 in `chat.py`)

### 5. Stage Message Mapping

**File:** `backend/domain/documents/service.py`

Add static method or constant dict for stage mapping:

```python
STAGE_MESSAGES = {
    "initializing": "Preparing document...",
    "reading": "Reading document content...",
    "understanding": "Analyzing document structure...",
    "building_connections": "Building knowledge connections...",
    "finalizing": "Completing processing...",
    "completed": "Document ready",
    "failed": "Processing failed"
}
```

Map technical phases to user-friendly stages:
- Text extraction/OCR → "reading"
- RAG Phase 1 (entity extraction) → "understanding"
- RAG Phase 2 (relationship extraction) → "building_connections"
- RAG Phase 3 (final merge/storage) → "finalizing"
- Storage completion → "completed"

---

## Frontend Changes

### 6. Streaming Upload API

**File:** `covenantrix-desktop/src/services/api/DocumentApi.ts`

Create new method following the pattern from `ChatApi.ts` (lines 70-98):

```typescript
async *uploadDocumentsStream(
  files: File[]
): AsyncGenerator<BatchProgressEvent, void, unknown>
```

Implementation:
- Create FormData with files
- POST to `/documents/upload/stream`
- Parse SSE stream with `data: ` prefix
- Yield parsed `BatchProgressEvent` objects
- Handle stream completion and errors
- Follow exact SSE parsing pattern from `ChatApi.sendMessageStream()`

### 7. Upload Hook Enhancement

**File:** `covenantrix-desktop/src/hooks/useUpload.ts`

Extend `FileItem` interface to include:
```typescript
stage?: 'initializing' | 'reading' | 'understanding' | 'building_connections' | 'finalizing' | 'completed' | 'failed'
stageMessage?: string
```

Modify `uploadLocalFiles()` function:
- Detect if single or batch upload
- For batch uploads: call new `uploadDocumentsStream()` API
- For each progress event:
  1. Extract file progress from `BatchProgressEvent`
  2. Update corresponding file's `stage`, `stageMessage`, `progress`
  3. Call `updateFileStatus()` with new stage info
  4. Update `uploadProgress` state with current file and overall progress

Keep existing non-streaming upload as fallback for single files or error handling.

### 8. Progress Component Enhancement

**File:** `covenantrix-desktop/src/features/upload/components/UploadProgress.tsx`

Add stage display to file list items (lines 116-143):

1. Create `getStageIcon()` helper function (similar to `getStatusIcon()`) that returns icons for each stage:
   - `initializing`: Clock icon
   - `reading`: FileText icon  
   - `understanding`: Brain/Sparkles icon
   - `building_connections`: Network icon
   - `finalizing`: CheckCircle icon
   - `completed`: CheckCircle (green)
   - `failed`: XCircle (red)

2. Update file item display (lines 117-141) to show:
   - Current stage icon
   - Stage message (user-friendly text)
   - Progress bar for files in processing (not pending/completed/failed)
   - Stage progress percentage during processing

3. Add stage progress bar component:
   ```tsx
   {file.stage && !['completed', 'failed', 'pending'].includes(file.stage) && (
     <div className="w-full bg-gray-200 rounded-full h-1 mt-1">
       <div 
         className="bg-blue-500 h-1 rounded-full transition-all"
         style={{ width: `${file.progress || 0}%` }}
       />
     </div>
   )}
   ```

4. Update "current file" display (lines 99-108) to show detailed stage:
   ```tsx
   <span className="text-sm font-medium">
     {current} - {currentStageMessage}
   </span>
   ```

### 9. Type Definitions

**File:** `covenantrix-desktop/src/types/documents.ts`

Add new types matching backend schemas:

```typescript
export type DocumentProgressStage = 
  | 'initializing'
  | 'reading' 
  | 'understanding'
  | 'building_connections'
  | 'finalizing'
  | 'completed'
  | 'failed'

export interface DocumentProgressEvent {
  filename: string
  document_id?: string
  stage: DocumentProgressStage
  message: string
  progress_percent: number
  timestamp: string
  error?: string
}

export interface BatchProgressEvent {
  total_files: number
  current_file_index: number
  file_progress: DocumentProgressEvent
  overall_progress_percent: number
}
```

---

## Implementation Notes

### Progress Calculation
- Overall progress = (completed_files + current_file_progress/100) / total_files * 100
- Per-file stages weighted equally: initializing (10%), reading (25%), understanding (50%), building_connections (75%), finalizing (90%), completed (100%)

### Error Handling
- If SSE connection fails: fall back to existing non-streaming upload
- If progress event parsing fails: log error and continue processing
- Emit "failed" stage event on any processing exception with error message

### State Persistence
- DocumentRegistry stores last known stage for each document
- On frontend re-mount: fetch document list and show last known stage for "processing" documents
- Add optional GET endpoint `/documents/{id}/progress` to retrieve current stage

### Backward Compatibility
- Keep existing `/documents/upload/batch` endpoint unchanged
- New streaming endpoint is opt-in via frontend code
- Non-streaming upload remains as fallback

### Testing Considerations
- Test with single file upload
- Test with batch upload (multiple files)
- Test network interruption during stream
- Test navigation away and back during upload
- Test stage progress display for each processing phase
- Verify Hebrew/RTL text displays correctly in stage messages

---

## Files to Modify

**Backend:**
1. `backend/api/schemas/documents.py` - Add progress event schemas
2. `backend/domain/documents/service.py` - Add progress callbacks and stage mapping
3. `backend/infrastructure/storage/document_registry.py` - Add stage persistence
4. `backend/api/routes/documents.py` - Create SSE streaming endpoint

**Frontend:**
5. `covenantrix-desktop/src/types/documents.ts` - Add progress type definitions
6. `covenantrix-desktop/src/services/api/DocumentApi.ts` - Add streaming upload method
7. `covenantrix-desktop/src/hooks/useUpload.ts` - Integrate streaming progress
8. `covenantrix-desktop/src/features/upload/components/UploadProgress.tsx` - Enhance stage display

---

## Success Criteria

- Users see real-time stage updates (reading, understanding, building connections, finalizing) for each uploaded document
- Progress bars show granular progress within each stage
- Stage information persists in DocumentRegistry and survives page navigation
- Implementation reuses existing SSE infrastructure without new dependencies
- Backward compatible with existing upload flow
- Clear, user-friendly stage messages in English (can be localized later)

