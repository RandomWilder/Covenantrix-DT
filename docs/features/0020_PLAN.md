# Feature 0020: JWT-Based Subscription & Tier Management System

## Overview

Implement a complete subscription tier system with JWT-based license validation to control feature access based on user subscription level. System supports 4 tiers (TRIAL → FREE ⇄ PAID ⇄ PAID_LIMITED) with automatic tier transitions, usage tracking for queries/documents, and enforcement of tier-specific limits throughout the application.

**Tier Structure:**
- **TRIAL**: 7 days from first launch, 3 docs max, 10MB per doc, unlimited queries, default API keys
- **FREE**: Indefinite, 3 docs max, 10MB per doc, 50 queries/month + 20/day, custom keys only
- **PAID**: Unlimited docs/queries, 100MB per doc, default keys available
- **PAID_LIMITED**: 7-day grace period, shows first 3 docs only, FREE tier limits, custom keys only

---

## Phase 1: Core Infrastructure & Data Layer

**Goal:** Establish subscription data models, storage, JWT validation, and tier configuration. Testable via backend endpoints.

### 1.1 Backend Schema Extensions

**File:** `backend/api/schemas/settings.py`

Add new models after existing settings classes:

```python
class FeatureFlags(BaseModel):
    """Tier-based feature limits"""
    max_documents: int = Field(default=3, description="Max documents (-1 = unlimited)")
    max_doc_size_mb: int = Field(default=10, description="Max per-document size")
    max_total_storage_mb: int = Field(default=30, description="Max total storage")
    max_queries_monthly: int = Field(default=-1, description="Monthly query limit (-1 = unlimited)")
    max_queries_daily: int = Field(default=-1, description="Daily query limit (-1 = unlimited)")
    use_default_keys: bool = Field(default=False, description="Allow default API keys")

class SubscriptionSettings(BaseModel):
    """User subscription state - system-managed"""
    tier: str = Field(default="trial", description="trial|free|paid|paid_limited")
    license_key: Optional[str] = Field(default=None, description="JWT license token")
    trial_started_at: Optional[str] = Field(default=None, description="ISO datetime of first launch")
    trial_expires_at: Optional[str] = Field(default=None, description="ISO datetime when trial ends")
    grace_period_started_at: Optional[str] = Field(default=None, description="When grace period began")
    grace_period_expires_at: Optional[str] = Field(default=None, description="When grace period ends")
    features: FeatureFlags = Field(default_factory=FeatureFlags)
    last_tier_change: Optional[str] = Field(default=None, description="ISO datetime of last tier change")
```

Update `UserSettings` class to include:
```python
subscription: SubscriptionSettings = Field(default_factory=SubscriptionSettings)
```

### 1.2 Tier Configuration

**File:** `backend/domain/subscription/tier_config.py` (NEW)

```python
TIER_LIMITS = {
    "trial": {
        "max_documents": 3,
        "max_doc_size_mb": 10,
        "max_total_storage_mb": 30,
        "max_queries_monthly": -1,
        "max_queries_daily": -1,
        "use_default_keys": True,
        "duration_days": 7
    },
    "free": {
        "max_documents": 3,
        "max_doc_size_mb": 10,
        "max_total_storage_mb": 30,
        "max_queries_monthly": 50,
        "max_queries_daily": 20,
        "use_default_keys": False,
        "duration_days": None
    },
    "paid": {
        "max_documents": -1,
        "max_doc_size_mb": 100,
        "max_total_storage_mb": -1,
        "max_queries_monthly": -1,
        "max_queries_daily": -1,
        "use_default_keys": True,
        "duration_days": None
    },
    "paid_limited": {
        "max_documents": 3,
        "max_doc_size_mb": 10,
        "max_total_storage_mb": 30,
        "max_queries_monthly": 50,
        "max_queries_daily": 20,
        "use_default_keys": False,
        "grace_period_days": 7
    }
}

def get_tier_features(tier: str) -> dict:
    """Extract feature flags from tier config"""
    config = TIER_LIMITS[tier]
    return {k: v for k, v in config.items() 
            if k not in ["duration_days", "grace_period_days"]}
```

### 1.3 Usage Tracking Storage

**File:** `backend/infrastructure/storage/usage_tracker.py` (NEW)

Storage file: `~/.covenantrix/rag_storage/usage_tracking.json`

Structure:
```json
{
  "version": "1.0",
  "usage": {
    "queries": {
      "monthly": {"count": 0, "reset_date": "ISO", "history": []},
      "daily": {"count": 0, "reset_date": "ISO", "history": []}
    },
    "documents": {
      "total_count": 0,
      "current_visible": 0,
      "upload_history": []
    }
  }
}
```

Methods to implement:
- `record_query(tier: str) -> bool` - Record query, return False if limit exceeded
- `get_remaining_queries(tier: str) -> dict` - Get remaining quotas
- `reset_if_expired()` - Check and reset monthly/daily counters
- `record_document_upload(doc_id: str, size_mb: float)` - Track document upload
- `get_document_count() -> int` - Get current document count

### 1.4 JWT License Validator

**File:** `backend/domain/subscription/license_validator.py` (NEW)

Add to `requirements.txt`:
```
PyJWT==2.8.0
cryptography==41.0.0
```

JWT Payload Structure:
```json
{
  "tier": "paid",
  "issued": 1734567890000,
  "expiry": 1766103890000,
  "license_id": "uuid-v4",
  "features": {
    "max_documents": -1,
    "max_queries_monthly": -1,
    "max_doc_size_mb": 100,
    "use_default_keys": true
  }
}
```

Methods:
- `validate_jwt(token: str) -> dict` - Decode and validate JWT, check expiry
- `extract_tier_info(payload: dict) -> SubscriptionSettings` - Convert payload to settings

Public key embedded in code (private key kept secure offline for license generation).

### 1.5 Subscription Service

**File:** `backend/domain/subscription/service.py` (NEW)

Core orchestration service:

```python
class SubscriptionService:
    def __init__(
        self, 
        settings_storage: UserSettingsStorage,
        usage_tracker: UsageTracker,
        license_validator: LicenseValidator,
        notification_service: NotificationService
    )
```

Methods to implement:
- `get_current_subscription() -> SubscriptionSettings` - Load from user_settings.json
- `activate_license(jwt_token: str) -> SubscriptionSettings` - Validate JWT, update tier
- `check_tier_expiry() -> bool` - Check trial/grace period expiry on startup
- `transition_tier(new_tier: str, reason: str)` - Handle tier changes with notifications
- `check_upload_allowed() -> tuple[bool, str]` - Check document count limit
- `check_query_allowed() -> tuple[bool, str]` - Check query limits via UsageTracker
- `record_query()` - Delegate to UsageTracker
- `get_current_limits() -> dict` - Get FeatureFlags for current tier
- `get_remaining_queries() -> dict` - Get remaining quotas
- `_initialize_trial_if_needed()` - Set trial_started_at on first launch
- `_handle_trial_expiry()` - Auto-downgrade trial → free
- `_handle_grace_period_expiry()` - Auto-downgrade paid_limited → free, delete hidden docs

### 1.6 Subscription API Routes

**File:** `backend/api/routes/subscription.py` (NEW)

Endpoints:
- `GET /subscription/status` - Get current tier, features, usage stats
- `POST /subscription/activate` - Activate license key (JWT)
- `GET /subscription/usage` - Get remaining quotas
- `POST /subscription/validate-license` - Validate JWT token (dev/testing)

Response formats:
```python
class SubscriptionStatusResponse(BaseModel):
    tier: str
    features: FeatureFlags
    trial_expires_at: Optional[str]
    grace_period_expires_at: Optional[str]
    usage: dict  # From UsageTracker

class LicenseActivationRequest(BaseModel):
    license_key: str

class LicenseActivationResponse(BaseModel):
    success: bool
    new_tier: str
    message: str
```

### 1.7 Backend Startup Integration

**File:** `backend/main.py`

In `lifespan()` function, after loading user_settings (around line 82):

```python
# Initialize subscription service
from domain.subscription.service import SubscriptionService
from infrastructure.storage.usage_tracker import UsageTracker
from domain.subscription.license_validator import LicenseValidator

usage_tracker = UsageTracker(settings.storage.working_dir)
license_validator = LicenseValidator()
subscription_service = SubscriptionService(
    settings_storage=user_settings_storage,
    usage_tracker=usage_tracker,
    license_validator=license_validator,
    notification_service=notification_service  # Already initialized later in lifespan
)

# Initialize trial on first launch
await subscription_service.check_tier_expiry()

# Store globally for dependency injection
from core.dependencies import set_subscription_service
set_subscription_service(subscription_service)
```

**File:** `backend/core/dependencies.py`

Add global state management:
```python
_subscription_service: Optional[SubscriptionService] = None

def set_subscription_service(service: SubscriptionService):
    global _subscription_service
    _subscription_service = service

def get_subscription_service() -> SubscriptionService:
    if _subscription_service is None:
        raise RuntimeError("Subscription service not initialized")
    return _subscription_service
```

### 1.8 Settings Storage Migration

**File:** `backend/infrastructure/storage/user_settings_storage.py`

Update `_migrate_settings()` method to add subscription field if missing:

```python
if "subscription" not in data:
    logger.info("Adding subscription section to settings")
    data["subscription"] = {
        "tier": "trial",
        "features": get_tier_features("trial")
    }
    needs_save = True
```

### 1.9 Include Router in Main App

**File:** `backend/main.py`

Add to imports:
```python
from api.routes import subscription
```

Add to router includes (around line 227):
```python
app.include_router(subscription.router)
```

**Phase 1 Testing:**
- Start backend, verify trial auto-activation in user_settings.json
- Call `GET /subscription/status` - should return tier="trial"
- Test JWT activation via `POST /subscription/activate` with valid/invalid tokens
- Verify usage_tracking.json file creation
- Test tier expiry by manually setting trial_expires_at to past date, restart backend

---

## Phase 2: Enforcement & Usage Tracking

**Goal:** Implement limit enforcement in upload/query operations, API key mode validation, document visibility filtering. Testable via API calls that hit limits.

### 2.1 Document Upload Limit Enforcement

**File:** `backend/api/routes/documents.py`

In `upload_document()` endpoint (before line 58):

```python
@router.post("/upload", response_model=DocumentUploadResponse)
async def upload_document(
    file: UploadFile = File(...),
    service: DocumentService = Depends(get_document_service),
    ocr_service: Optional[OCRService] = Depends(get_ocr_service),
    subscription_service: SubscriptionService = Depends(get_subscription_service)
):
    # Existing API key check...
    
    # NEW: Check subscription limits
    can_upload, reason = await subscription_service.check_upload_allowed()
    if not can_upload:
        raise HTTPException(
            status_code=402,  # Payment Required
            detail={
                "error": "upload_limit_reached",
                "message": reason,
                "current_tier": subscription_service.get_current_subscription().tier,
                "upgrade_required": True
            }
        )
    
    # NEW: Check file size against tier limit
    file_content = await file.read()
    file_size_mb = len(file_content) / (1024 * 1024)
    tier_limits = subscription_service.get_current_limits()
    
    if file_size_mb > tier_limits["max_doc_size_mb"]:
        raise HTTPException(
            status_code=413,  # Payload Too Large
            detail={
                "error": "file_too_large",
                "file_size_mb": round(file_size_mb, 2),
                "max_size_mb": tier_limits["max_doc_size_mb"],
                "current_tier": subscription_service.get_current_subscription().tier
            }
        )
    
    # Record document upload
    await subscription_service.record_document_upload(file.filename, file_size_mb)
    
    # Continue with existing upload logic...
```

Apply same pattern to `upload_documents_stream()` endpoint.

### 2.2 Query Limit Enforcement

**File:** `backend/api/routes/queries.py`

In query endpoint (likely `query_documents()` or similar):

```python
async def query_documents(
    request: QueryRequest,
    subscription_service: SubscriptionService = Depends(get_subscription_service)
):
    # NEW: Check query limits
    can_query, reason = await subscription_service.check_query_allowed()
    if not can_query:
        remaining = await subscription_service.get_remaining_queries()
        raise HTTPException(
            status_code=429,  # Too Many Requests
            detail={
                "error": "query_limit_reached",
                "message": reason,
                "remaining_monthly": remaining["monthly_remaining"],
                "remaining_daily": remaining["daily_remaining"],
                "reset_dates": remaining["reset_dates"]
            }
        )
    
    # Execute query (existing logic)
    result = await document_service.query_documents(...)
    
    # NEW: Record query usage
    await subscription_service.record_query()
    
    return result
```

**File:** `backend/api/routes/chat.py`

Apply same pattern to chat endpoints that use RAG queries.

### 2.3 Document Visibility Filtering

**File:** `backend/domain/documents/service.py`

Update `list_documents()` method signature and implementation:

```python
async def list_documents(
    self,
    include_deleted: bool = False,
    subscription_tier: Optional[str] = None  # NEW parameter
) -> List[Document]:
    """List documents with tier-based visibility"""
    
    docs = await self.registry.list_documents(include_deleted=include_deleted)
    
    # NEW: Apply tier filtering
    if subscription_tier:
        from domain.subscription.tier_config import TIER_LIMITS
        
        if subscription_tier == "paid_limited":
            # Show only first 3 documents by upload date
            docs = sorted(docs, key=lambda d: d.created_at)[:3]
        else:
            # Apply max_documents limit if not unlimited
            max_docs = TIER_LIMITS[subscription_tier]["max_documents"]
            if max_docs != -1:
                docs = sorted(docs, key=lambda d: d.created_at)[:max_docs]
    
    return docs
```

**File:** `backend/api/routes/documents.py`

Update `list_documents()` endpoint to pass tier:

```python
@router.get("", response_model=DocumentListResponse)
async def list_documents(
    service: DocumentService = Depends(get_document_service),
    subscription_service: SubscriptionService = Depends(get_subscription_service)
):
    current_tier = subscription_service.get_current_subscription().tier
    documents = await service.list_documents(subscription_tier=current_tier)
    # ... rest of logic
```

### 2.4 API Key Mode Validation

**File:** `backend/api/routes/settings.py`

In `update_settings()` endpoint, after existing validation (around line 157):

```python
# NEW: Validate API key mode against subscription tier
if request.settings.api_keys.mode == "default":
    from core.dependencies import get_subscription_service
    subscription_service = get_subscription_service()
    current_subscription = subscription_service.get_current_subscription()
    
    if not current_subscription.features.use_default_keys:
        raise HTTPException(
            status_code=403,
            detail={
                "error": "default_keys_not_allowed",
                "message": f"Your {current_subscription.tier} tier requires custom API keys",
                "current_tier": current_subscription.tier,
                "allowed_mode": "custom"
            }
        )
```

### 2.5 Tier Transition with Document Hiding

**File:** `backend/domain/subscription/service.py`

Implement `transition_tier()` method:

```python
async def transition_tier(self, new_tier: str, reason: str):
    """Handle tier transitions with proper cleanup and notifications"""
    settings = await self.settings_storage.load_settings()
    old_tier = settings.subscription.tier
    
    logger.info(f"Tier transition: {old_tier} -> {new_tier} (reason: {reason})")
    
    # Update tier and features
    settings.subscription.tier = new_tier
    settings.subscription.features = FeatureFlags(**get_tier_features(new_tier))
    settings.subscription.last_tier_change = datetime.utcnow().isoformat()
    
    # Handle specific transitions
    if old_tier == "trial" and new_tier == "free":
        # Force custom API key mode
        settings.api_keys.mode = "custom"
        await self.notification_service.create(
            type="warning",
            title="Trial Ended",
            message="Your 7-day trial has ended. Please configure your own API keys in Settings to continue using the app.",
            priority="high"
        )
    
    elif old_tier == "paid" and new_tier == "paid_limited":
        # Start grace period
        now = datetime.utcnow()
        settings.subscription.grace_period_started_at = now.isoformat()
        settings.subscription.grace_period_expires_at = (now + timedelta(days=7)).isoformat()
        
        # Force custom API key mode
        settings.api_keys.mode = "custom"
        
        await self.notification_service.create(
            type="error",
            title="Payment Issue Detected",
            message="You have 7 days to resolve payment. Access limited to first 3 documents.",
            priority="high"
        )
    
    elif old_tier == "paid_limited" and new_tier == "free":
        # End grace period, delete hidden documents
        settings.subscription.grace_period_started_at = None
        settings.subscription.grace_period_expires_at = None
        
        await self._delete_hidden_documents()
        
        await self.notification_service.create(
            type="info",
            title="Downgraded to Free Tier",
            message="Documents beyond the first 3 have been permanently deleted.",
            priority="high"
        )
    
    elif old_tier == "paid_limited" and new_tier == "paid":
        # Restore full access
        settings.subscription.grace_period_started_at = None
        settings.subscription.grace_period_expires_at = None
        
        await self.notification_service.create(
            type="success",
            title="Subscription Restored",
            message="Full access restored. All documents are now visible.",
            priority="normal"
        )
    
    elif new_tier == "free" and old_tier == "free":
        # User activated free tier (from trial) - force custom mode
        settings.api_keys.mode = "custom"
    
    # Save updated settings
    await self.settings_storage.save_settings(settings)
    
    logger.info(f"Tier transition complete: {old_tier} -> {new_tier}")
```

Implement `_delete_hidden_documents()` helper:

```python
async def _delete_hidden_documents(self):
    """Delete documents beyond first 3 (called on paid_limited -> free)"""
    from core.dependencies import get_document_service
    doc_service = get_document_service()
    
    all_docs = await doc_service.list_documents(include_deleted=False)
    docs_sorted = sorted(all_docs, key=lambda d: d.created_at)
    
    docs_to_delete = docs_sorted[3:]  # Everything after first 3
    
    for doc in docs_to_delete:
        await doc_service.delete_document(doc.id, hard_delete=True)
        logger.info(f"Deleted hidden document: {doc.id} ({doc.metadata.filename})")
    
    logger.info(f"Deleted {len(docs_to_delete)} hidden documents")
```

### 2.6 Grace Period Check on Startup

**File:** `backend/main.py`

In `lifespan()`, after subscription service initialization:

```python
# Check grace period expiry
subscription = subscription_service.get_current_subscription()
if subscription.tier == "paid_limited" and subscription.grace_period_expires_at:
    expiry = datetime.fromisoformat(subscription.grace_period_expires_at)
    if datetime.utcnow() >= expiry:
        logger.warning("Grace period expired, downgrading to FREE tier")
        await subscription_service.transition_tier("free", reason="grace_period_expired")
```

**Phase 2 Testing:**
- Upload documents until limit reached, verify 402 error
- Upload file exceeding tier size limit, verify 413 error
- Make queries until daily/monthly limit reached, verify 429 error
- Try setting mode="default" in FREE tier, verify 403 error
- Manually transition tier via subscription service, verify document hiding
- Set grace_period_expires_at to past, restart backend, verify auto-downgrade to FREE

---

## Phase 3: Frontend Integration & UI

**Goal:** Integrate subscription context into frontend, implement feature gates, usage displays, license activation UI. Testable via full user workflows.

### 3.1 Frontend Type Definitions

**File:** `covenantrix-desktop/src/types/subscription.ts`

Replace existing stub types with:

```typescript
export type SubscriptionTier = 'trial' | 'free' | 'paid' | 'paid_limited';

export interface FeatureFlags {
  max_documents: number;
  max_doc_size_mb: number;
  max_total_storage_mb: number;
  max_queries_monthly: number;
  max_queries_daily: number;
  use_default_keys: boolean;
}

export interface SubscriptionSettings {
  tier: SubscriptionTier;
  license_key?: string;
  trial_started_at?: string;
  trial_expires_at?: string;
  grace_period_started_at?: string;
  grace_period_expires_at?: string;
  features: FeatureFlags;
  last_tier_change?: string;
}

export interface UsageStats {
  documents_uploaded: number;
  queries_this_month: number;
  queries_today: number;
  monthly_remaining: number;
  daily_remaining: number;
  monthly_reset_date: string;
  daily_reset_date: string;
}

export interface SubscriptionContextValue {
  subscription: SubscriptionSettings | null;
  usage: UsageStats | null;
  isLoading: boolean;
  canUploadDocument: () => boolean;
  canSendQuery: () => Promise<boolean>;
  getRemainingQuota: (resource: 'documents' | 'queries') => number;
  activateLicense: (key: string) => Promise<void>;
  getDaysRemaining: (type: 'trial' | 'grace') => number | null;
}
```

### 3.2 Subscription Context Implementation

**File:** `covenantrix-desktop/src/contexts/SubscriptionContext.tsx`

Replace empty file with full implementation:

```typescript
import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { SubscriptionSettings, UsageStats, SubscriptionContextValue } from '../types/subscription';
import { isElectron } from '../utils/environment';

const SubscriptionContext = createContext<SubscriptionContextValue | undefined>(undefined);

export const SubscriptionProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [subscription, setSubscription] = useState<SubscriptionSettings | null>(null);
  const [usage, setUsage] = useState<UsageStats | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    loadSubscription();
  }, []);

  const loadSubscription = useCallback(async () => {
    if (!isElectron()) return;
    
    try {
      const response = await window.electronAPI.getSubscriptionStatus();
      if (response.success) {
        setSubscription(response.data.subscription);
        setUsage(response.data.usage);
      }
    } catch (error) {
      console.error('Failed to load subscription:', error);
    } finally {
      setIsLoading(false);
    }
  }, []);

  const canUploadDocument = useCallback((): boolean => {
    if (!subscription || !usage) return false;
    
    const { max_documents } = subscription.features;
    if (max_documents === -1) return true;
    
    return usage.documents_uploaded < max_documents;
  }, [subscription, usage]);

  const canSendQuery = useCallback(async (): Promise<boolean> => {
    if (!subscription || !usage) return false;
    
    const { max_queries_monthly, max_queries_daily } = subscription.features;
    
    if (max_queries_monthly !== -1 && usage.monthly_remaining <= 0) return false;
    if (max_queries_daily !== -1 && usage.daily_remaining <= 0) return false;
    
    return true;
  }, [subscription, usage]);

  const getRemainingQuota = useCallback((resource: 'documents' | 'queries'): number => {
    if (!subscription || !usage) return 0;
    
    if (resource === 'documents') {
      const max = subscription.features.max_documents;
      if (max === -1) return -1;
      return Math.max(0, max - usage.documents_uploaded);
    } else {
      return Math.min(
        usage.monthly_remaining !== -1 ? usage.monthly_remaining : Infinity,
        usage.daily_remaining !== -1 ? usage.daily_remaining : Infinity
      ) as number;
    }
  }, [subscription, usage]);

  const activateLicense = useCallback(async (key: string): Promise<void> => {
    if (!isElectron()) throw new Error('License activation only available in desktop app');
    
    const response = await window.electronAPI.activateLicense(key);
    if (response.success) {
      await loadSubscription();
    } else {
      throw new Error(response.error || 'License activation failed');
    }
  }, [loadSubscription]);

  const getDaysRemaining = useCallback((type: 'trial' | 'grace'): number | null => {
    if (!subscription) return null;
    
    const expiryField = type === 'trial' ? subscription.trial_expires_at : subscription.grace_period_expires_at;
    if (!expiryField) return null;
    
    const expiry = new Date(expiryField);
    const now = new Date();
    const diff = expiry.getTime() - now.getTime();
    
    return Math.max(0, Math.ceil(diff / (1000 * 60 * 60 * 24)));
  }, [subscription]);

  const value: SubscriptionContextValue = {
    subscription,
    usage,
    isLoading,
    canUploadDocument,
    canSendQuery,
    getRemainingQuota,
    activateLicense,
    getDaysRemaining
  };

  return (
    <SubscriptionContext.Provider value={value}>
      {children}
    </SubscriptionContext.Provider>
  );
};

export const useSubscription = (): SubscriptionContextValue => {
  const context = useContext(SubscriptionContext);
  if (!context) {
    throw new Error('useSubscription must be used within SubscriptionProvider');
  }
  return context;
};
```

### 3.3 Add Subscription Provider to App

**File:** `covenantrix-desktop/src/main.tsx`

Update providers:

```typescript
import { SubscriptionProvider } from './contexts/SubscriptionContext'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <NotificationProvider>
      <SettingsProvider>
        <SubscriptionProvider>
          <App />
        </SubscriptionProvider>
      </SettingsProvider>
    </NotificationProvider>
  </React.StrictMode>,
)
```

### 3.4 IPC Handlers for Subscription

**File:** `covenantrix-desktop/electron/ipc-handlers.js`

Add handlers:

```javascript
ipcMain.handle('subscription:getStatus', async () => {
  try {
    const response = await axios.get(`${API_BASE}/subscription/status`);
    return { success: true, data: response.data };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

ipcMain.handle('subscription:activateLicense', async (event, licenseKey) => {
  try {
    const response = await axios.post(`${API_BASE}/subscription/activate`, {
      license_key: licenseKey
    });
    return { success: true, data: response.data };
  } catch (error) {
    return { 
      success: false, 
      error: error.response?.data?.detail?.message || error.message 
    };
  }
});
```

### 3.5 Preload API Definitions

**File:** `covenantrix-desktop/electron/preload.js`

Add to exposed API:

```javascript
subscription: {
  getStatus: () => ipcRenderer.invoke('subscription:getStatus'),
  activateLicense: (key) => ipcRenderer.invoke('subscription:activateLicense', key)
}
```

### 3.6 Feature Gate: Document Upload

**File:** `covenantrix-desktop/src/features/documents/DocumentUpload.tsx` (or similar upload component)

Before triggering upload:

```typescript
import { useSubscription } from '../../contexts/SubscriptionContext';

const { canUploadDocument, subscription, getRemainingQuota } = useSubscription();

const handleUpload = async (file: File) => {
  if (!canUploadDocument()) {
    const remaining = getRemainingQuota('documents');
    showUpgradeModal({
      title: 'Document Limit Reached',
      message: `You've reached the maximum of ${subscription?.features.max_documents} documents for the ${subscription?.tier} tier.`,
      action: subscription?.tier === 'trial' ? 'Upgrade to continue' : 'Manage subscription'
    });
    return;
  }
  
  // Check file size
  const fileSizeMB = file.size / (1024 * 1024);
  if (fileSizeMB > subscription?.features.max_doc_size_mb) {
    showError(`File too large. Maximum size: ${subscription?.features.max_doc_size_mb}MB`);
    return;
  }
  
  // Proceed with upload...
};
```

### 3.7 Feature Gate: Query/Chat

**File:** `covenantrix-desktop/src/features/chat/ChatInterface.tsx` (or similar)

Before sending query:

```typescript
const { canSendQuery, getRemainingQuota, subscription } = useSubscription();

const handleSendMessage = async (message: string) => {
  const allowed = await canSendQuery();
  if (!allowed) {
    const remaining = getRemainingQuota('queries');
    showUpgradeModal({
      title: 'Query Limit Reached',
      message: `You've used all queries for today/this month on the ${subscription?.tier} tier.`,
      details: `Remaining: ${remaining} queries`
    });
    return;
  }
  
  // Send message...
};
```

### 3.8 Trial Banner Component

**File:** `covenantrix-desktop/src/features/subscription/TrialBanner.tsx` (NEW)

```typescript
import { useSubscription } from '../../contexts/SubscriptionContext';

export const TrialBanner: React.FC = () => {
  const { subscription, getDaysRemaining } = useSubscription();
  
  if (subscription?.tier !== 'trial') return null;
  
  const daysLeft = getDaysRemaining('trial');
  if (daysLeft === null) return null;
  
  return (
    <div className="bg-blue-50 dark:bg-blue-900 border-b border-blue-200 dark:border-blue-700 px-4 py-2">
      <p className="text-sm text-blue-800 dark:text-blue-200">
        <strong>Trial:</strong> {daysLeft} days remaining. 
        <button className="ml-2 underline font-medium">Upgrade Now</button>
      </p>
    </div>
  );
};
```

Show in `AppLayout.tsx` or main layout component.

### 3.9 Grace Period Warning Component

**File:** `covenantrix-desktop/src/features/subscription/GracePeriodWarning.tsx` (NEW)

```typescript
export const GracePeriodWarning: React.FC = () => {
  const { subscription, getDaysRemaining } = useSubscription();
  
  if (subscription?.tier !== 'paid_limited') return null;
  
  const daysLeft = getDaysRemaining('grace');
  if (daysLeft === null) return null;
  
  return (
    <div className="bg-red-50 dark:bg-red-900 border-b border-red-200 dark:border-red-700 px-4 py-3">
      <p className="text-sm text-red-800 dark:text-red-200">
        <strong>Payment Issue:</strong> {daysLeft} days to resolve payment or data will be lost.
        <button className="ml-2 underline font-medium">Resolve Payment</button>
      </p>
    </div>
  );
};
```

### 3.10 Subscription Tab in Profile/Settings Modal

**File:** `covenantrix-desktop/src/features/settings/SubscriptionTab.tsx` (NEW)

```typescript
import { useSubscription } from '../../contexts/SubscriptionContext';

export const SubscriptionTab: React.FC = () => {
  const { subscription, usage, activateLicense, getRemainingQuota } = useSubscription();
  const [licenseKey, setLicenseKey] = useState('');
  const [isActivating, setIsActivating] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const handleActivate = async () => {
    setIsActivating(true);
    setError(null);
    try {
      await activateLicense(licenseKey);
      setLicenseKey('');
    } catch (err) {
      setError(err.message);
    } finally {
      setIsActivating(false);
    }
  };
  
  return (
    <div className="space-y-6">
      {/* Current Tier Display */}
      <div className="border rounded-lg p-4">
        <h3 className="font-semibold mb-2">Current Plan: {subscription?.tier.toUpperCase()}</h3>
        
        {/* Feature limits display */}
        <div className="space-y-2 text-sm">
          <div>Documents: {usage?.documents_uploaded || 0} / {subscription?.features.max_documents === -1 ? '∞' : subscription?.features.max_documents}</div>
          <div>Queries (Monthly): {usage?.queries_this_month || 0} / {subscription?.features.max_queries_monthly === -1 ? '∞' : subscription?.features.max_queries_monthly}</div>
          <div>Queries (Daily): {usage?.queries_today || 0} / {subscription?.features.max_queries_daily === -1 ? '∞' : subscription?.features.max_queries_daily}</div>
        </div>
      </div>
      
      {/* License Activation */}
      {subscription?.tier !== 'paid' && (
        <div className="border rounded-lg p-4">
          <h3 className="font-semibold mb-2">Activate License</h3>
          <input
            type="text"
            value={licenseKey}
            onChange={(e) => setLicenseKey(e.target.value)}
            placeholder="Paste license key here"
            className="w-full px-3 py-2 border rounded mb-2"
          />
          <button
            onClick={handleActivate}
            disabled={!licenseKey || isActivating}
            className="px-4 py-2 bg-blue-600 text-white rounded disabled:opacity-50"
          >
            {isActivating ? 'Activating...' : 'Activate License'}
          </button>
          {error && <p className="text-red-600 text-sm mt-2">{error}</p>}
        </div>
      )}
    </div>
  );
};
```

**File:** `covenantrix-desktop/src/features/settings/SettingsModal.tsx`

Add "Subscription" tab alongside existing tabs (API Keys, RAG, Language, etc.).

### 3.11 Upgrade Modal Component

**File:** `covenantrix-desktop/src/features/subscription/UpgradeModal.tsx` (NEW)

```typescript
interface UpgradeModalProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  message: string;
  currentTier: string;
}

export const UpgradeModal: React.FC<UpgradeModalProps> = ({
  isOpen, onClose, title, message, currentTier
}) => {
  if (!isOpen) return null;
  
  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md">
        <h2 className="text-xl font-bold mb-4">{title}</h2>
        <p className="mb-6">{message}</p>
        
        <div className="space-y-3">
          {currentTier === 'trial' && (
            <button className="w-full px-4 py-2 bg-blue-600 text-white rounded">
              Upgrade to Paid
            </button>
          )}
          {currentTier === 'free' && (
            <>
              <button className="w-full px-4 py-2 bg-blue-600 text-white rounded">
                Upgrade to Paid
              </button>
              <p className="text-sm text-gray-600">
                Or continue using your own API keys with current limits
              </p>
            </>
          )}
          <button onClick={onClose} className="w-full px-4 py-2 border rounded">
            Close
          </button>
        </div>
      </div>
    </div>
  );
};
```

Create global state/hook for showing this modal from anywhere.

### 3.12 Usage Stats Display Component

**File:** `covenantrix-desktop/src/features/subscription/UsageStatsWidget.tsx` (NEW)

Small widget showing remaining quotas in sidebar or header:

```typescript
export const UsageStatsWidget: React.FC = () => {
  const { usage, subscription, getRemainingQuota } = useSubscription();
  
  if (!subscription || subscription.tier === 'paid') return null;
  
  const docsRemaining = getRemainingQuota('documents');
  const queriesRemaining = getRemainingQuota('queries');
  
  return (
    <div className="text-xs text-gray-600 dark:text-gray-400">
      <div>Docs: {docsRemaining === -1 ? '∞' : docsRemaining} left</div>
      <div>Queries: {queriesRemaining === -1 ? '∞' : queriesRemaining} left</div>
    </div>
  );
};
```

### 3.13 Error Handling for Limit-Related Responses

**File:** `covenantrix-desktop/src/services/api/DocumentsApi.ts`

Catch 402/413 errors and show appropriate UI:

```typescript
try {
  const response = await axios.post('/documents/upload', formData);
  return response.data;
} catch (error) {
  if (error.response?.status === 402) {
    // Upload limit reached
    showUpgradeModal(error.response.data.detail);
    throw new Error('LIMIT_REACHED');
  } else if (error.response?.status === 413) {
    // File too large
    showError(`File too large: ${error.response.data.detail.message}`);
    throw new Error('FILE_TOO_LARGE');
  }
  throw error;
}
```

Similar for query API in `ChatApi.ts` (catch 429 errors).

**Phase 3 Testing:**
- Upload documents in UI until limit reached, verify upgrade modal appears
- Send queries until limit reached, verify upgrade modal appears
- Activate valid JWT license, verify tier upgrade and UI updates
- Check trial banner shows countdown
- Verify grace period warning shows for paid_limited tier
- Test subscription tab shows correct usage stats
- Verify document list shows only allowed documents based on tier

---

## Files Summary

### New Files Created:
- `backend/domain/subscription/tier_config.py`
- `backend/domain/subscription/license_validator.py`
- `backend/domain/subscription/service.py`
- `backend/infrastructure/storage/usage_tracker.py`
- `backend/api/routes/subscription.py`
- `covenantrix-desktop/src/features/subscription/TrialBanner.tsx`
- `covenantrix-desktop/src/features/subscription/GracePeriodWarning.tsx`
- `covenantrix-desktop/src/features/subscription/SubscriptionTab.tsx`
- `covenantrix-desktop/src/features/subscription/UpgradeModal.tsx`
- `covenantrix-desktop/src/features/subscription/UsageStatsWidget.tsx`

### Modified Files:
- `backend/api/schemas/settings.py` - Add FeatureFlags, SubscriptionSettings
- `backend/core/dependencies.py` - Add subscription service global state
- `backend/main.py` - Initialize subscription service, check expiry on startup
- `backend/infrastructure/storage/user_settings_storage.py` - Migrate subscription field
- `backend/api/routes/documents.py` - Add limit checks to upload endpoints
- `backend/api/routes/queries.py` - Add limit checks to query endpoints
- `backend/api/routes/chat.py` - Add limit checks to chat endpoints
- `backend/api/routes/settings.py` - Add API key mode validation
- `backend/domain/documents/service.py` - Add tier-based document filtering
- `backend/requirements.txt` - Add PyJWT, cryptography
- `covenantrix-desktop/src/contexts/SubscriptionContext.tsx` - Full implementation
- `covenantrix-desktop/src/types/subscription.ts` - Complete type definitions
- `covenantrix-desktop/src/main.tsx` - Add SubscriptionProvider
- `covenantrix-desktop/electron/ipc-handlers.js` - Add subscription IPC handlers
- `covenantrix-desktop/electron/preload.js` - Expose subscription API
- `covenantrix-desktop/src/features/settings/SettingsModal.tsx` - Add Subscription tab
- `covenantrix-desktop/src/components/layout/AppLayout.tsx` - Add banners/widgets

### Key Algorithms:

**Trial Activation (First Launch):**
1. Load user_settings.json
2. If `subscription.trial_started_at` is null:
   - Set to current UTC datetime
   - Calculate `trial_expires_at` = now + 7 days
   - Set tier = "trial"
   - Save settings
3. On every startup: Check if `trial_expires_at < now()` → Auto-downgrade to FREE

**Query Limit Reset:**
1. Load usage_tracking.json
2. Compare `monthly_reset_date` with now()
3. If now >= reset_date:
   - Reset `monthly.count` to 0
   - Set new `monthly_reset_date` = now + 30 days
   - Clear `monthly.history`
4. Repeat for daily counter (24-hour window)

**Document Visibility Filtering:**
1. Get user tier from settings
2. Load all documents from registry
3. Sort by `created_at` ascending (oldest first)
4. If tier == "paid_limited": Return first 3 only
5. Else if tier has max_documents limit: Return first N
6. Else: Return all

**JWT License Validation:**
1. Decode JWT using public key (RS256)
2. Check `expiry` field > current timestamp (in milliseconds)
3. Validate required fields: tier, issued, license_id, features
4. Extract tier and features
5. Update user_settings.json with new tier
6. Trigger tier transition logic (notifications, API key mode enforcement)

