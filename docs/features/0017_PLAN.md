# Feature 0017: Notification System - Phase 1 Infrastructure

## Overview
Implement core notification infrastructure with empty state functionality. Establishes backend domain layer, storage, API endpoints, frontend context, UI components, and IPC bridge. Includes POST endpoint for notification creation (required for Phase 2 update notifications). No notifications generated in this phase - system architecture and UI foundation only.

---

## Backend Implementation

### 1. Domain Layer - Models
**New File:** `backend/domain/notifications/__init__.py`
- Empty init file for package

**New File:** `backend/domain/notifications/models.py`
- `NotificationAction` dataclass: label (str), action (str), url (Optional[str])
- `Notification` dataclass: id, type, source (Literal['local', 'cloud']), title, summary, content (optional), actions (List[NotificationAction]), timestamp, read (bool), dismissed (bool), metadata (dict), expires_at (optional)

### 2. Domain Layer - Service
**New File:** `backend/domain/notifications/service.py`
- `NotificationService` class with storage dependency
- `create_notification()` - Create new notification with UUID generation, supports dedup_key in metadata
- `get_all_notifications()` - Retrieve all notifications sorted newest first (timestamp desc)
- `get_unread_count()` - Count where `read=False AND dismissed=False`
- `mark_as_read(notification_id)` - Mark single notification as read
- `dismiss_notification(notification_id)` - Set dismissed=True
- `cleanup_expired()` - Delete notifications older than 7 days
- Deduplication logic: Check metadata.dedup_key before creating, return existing if found and not dismissed

### 3. Domain Layer - Exceptions
**New File:** `backend/domain/notifications/exceptions.py`
- `NotificationError(Exception)` - Base exception
- `NotificationNotFoundError(NotificationError)` - Notification not found
- `NotificationStorageError(NotificationError)` - Storage operation failed

### 4. Infrastructure Layer - Storage
**New File:** `backend/infrastructure/storage/notification_storage.py`
- `NotificationStorage` class following `chat_storage.py` pattern
- Storage path: `~/.covenantrix/rag_storage/notifications.json`
- Schema: `{"notifications": [...]}`
- Methods (all async for consistency):
  - `async def save_notification(notification)` - Atomic write with file locking
  - `async def get_all_notifications()` - Load all, sorted newest first
  - `async def find_by_id(notification_id)` - Retrieve single notification
  - `async def find_by_metadata(key, value)` - Find by metadata field (for deduplication)
  - `async def update_notification(notification)` - Update existing
  - `async def delete_notification(notification_id)` - Remove from storage
  - `async def delete_expired(cutoff_date)` - Bulk delete old notifications
  - `_notification_to_dict()` - Serialize with ISO datetime
  - `_dict_to_notification()` - Deserialize with datetime parsing
- Thread-safe operations using file locking or atomic write patterns

### 5. API Layer - Routes
**New File:** `backend/api/routes/notifications.py`
- Router with prefix `/api/notifications`, tag `["notifications"]`
- Endpoints:
  - `GET /api/notifications` - List all (response_model=NotificationListResponse)
  - `GET /api/notifications/unread-count` - Get unread count (response_model=UnreadCountResponse)
  - `PUT /api/notifications/{id}/read` - Mark as read (response_model=NotificationResponse)
  - `DELETE /api/notifications/{id}` - Dismiss notification (response_model=DeleteResponse)
  - `POST /api/notifications/cleanup` - Manual cleanup trigger (response_model=CleanupResponse)
  - `POST /api/notifications` - Create notification (response_model=NotificationResponse) **[NEW - Required for Phase 2]**
- All endpoints use `Depends(get_notification_service)` dependency injection

### 6. API Layer - Schemas
**New File:** `backend/api/schemas/notifications.py`
- `NotificationActionSchema(BaseModel)` - label, action, url
- `NotificationResponse(BaseModel)` - API response for single notification
- `NotificationListResponse(BaseModel)` - List wrapper with notifications array
- `UnreadCountResponse(BaseModel)` - count field
- `DeleteResponse(BaseModel)` - success bool, message
- `CleanupResponse(BaseModel)` - deleted_count, success
- `CreateNotificationRequest(BaseModel)` - type, source, title, summary, content, actions, metadata **[NEW]**
- `from_domain()` classmethod on NotificationResponse for domainâ†’API conversion

### 7. Dependency Injection
**Modify File:** `backend/core/dependencies.py`
- Import NotificationStorage, NotificationService
- Add global singleton: `_notification_storage: Optional[NotificationStorage] = None`
- `get_notification_storage(settings: Settings = Depends(get_config)) -> NotificationStorage` - Return singleton, initialize if None with working_dir from settings
- `get_notification_service(storage: NotificationStorage = Depends(get_notification_storage)) -> NotificationService` - Create service with storage dependency

### 8. Router Registration
**Modify File:** `backend/main.py`
- Import notifications router: `from api.routes import notifications`
- Register router: `app.include_router(notifications.router, tags=["notifications"])`
- Add cleanup on startup: Call `notification_service.cleanup_expired()` in startup event handler

### 9. Startup Cleanup Trigger
**Modify File:** `backend/main.py`
- In `@app.on_event("startup")` handler (or create if not exists)
- Get notification service and call cleanup_expired() with cutoff_date = now - 7 days
- Log cleanup results

---

## Frontend Implementation

### 1. Type Definitions
**New File:** `covenantrix-desktop/src/types/notification.ts`
- `NotificationAction` interface: label, action, url?
- `Notification` interface: id, type, source, title, summary, content?, actions?, timestamp, read, dismissed, metadata?
- `NotificationContextValue` interface: notifications, unreadCount, isLoading, expandedNotifications (Set<string>), fetchNotifications(), markAsRead(id), dismissNotification(id), toggleExpanded(id), handleAction(notificationId, action)

### 2. Notification Service (API Layer)
**New File:** `covenantrix-desktop/src/services/api/notificationService.ts`
- Export `notificationService` object with methods:
  - `getAll(): Promise<Notification[]>` - Calls window.electronAPI.notifications.getAll()
  - `getUnreadCount(): Promise<number>` - Calls getUnreadCount()
  - `markAsRead(id: string): Promise<void>` - Calls markAsRead(id)
  - `dismiss(id: string): Promise<void>` - Calls dismiss(id)
  - `cleanup(): Promise<void>` - Calls cleanup()
- All methods use window.electronAPI.notifications IPC bridge

### 3. Notification Context
**New File:** `covenantrix-desktop/src/contexts/NotificationContext.tsx`
- `NotificationProvider` component following `SettingsContext.tsx` pattern
- State: notifications (Notification[]), unreadCount (number), isLoading (bool), expandedNotifications (Set<string>)
- `fetchNotifications()` - Load from API, update state, calculate unreadCount
- `markAsRead(id)` - Call API, update local state
- `dismissNotification(id)` - Call API, remove from local state
- `toggleExpanded(id)` - Add/remove from expandedNotifications Set, auto-mark as read when expanding
- `handleAction(notificationId, action)` - Dispatch action based on action type (stub implementation for Phase 1)
- Auto-refresh: useEffect with 60-second interval calling fetchNotifications()
- Export `useNotifications()` hook throwing error if used outside provider

### 4. Notification Modal Component
**New File:** `covenantrix-desktop/src/features/notifications/NotificationModal.tsx`
- Props: `isOpen: boolean, onClose: () => void`
- Follow `SettingsModal.tsx` modal pattern (overlay, z-index, centered)
- Header: "Notifications" title, close button (X icon)
- Body: Scrollable list of NotificationCard components or EmptyState
- Use `useNotifications()` hook for data
- Conditional render: notifications.length === 0 ? <EmptyState /> : map NotificationCard

### 5. Notification Card Component
**New File:** `covenantrix-desktop/src/features/notifications/NotificationCard.tsx`
- Props: `notification: Notification, isExpanded: boolean, onToggle: () => void, onDismiss: (id: string) => void, onAction: (id: string, action: string) => void`
- Collapsed state: Title, summary preview, timestamp (relative), dismiss X button
- Expanded state: Full content, action buttons (if actions exist)
- Visual states: Unread (bold title, subtle bg), Read (normal)
- Timestamp formatting: Use relative time ("2m ago", "1h ago", "2d ago") - implement simple formatter or use date-fns
- Click card to toggle expansion (calls onToggle which marks as read)
- Action buttons rendered when expanded: Map notification.actions to buttons with onClick calling onAction

### 6. Empty State Component
**New File:** `covenantrix-desktop/src/features/notifications/EmptyState.tsx`
- Display: Bell icon (from lucide-react, muted color), "No notifications" text, friendly subtitle
- Center aligned, padding for visual balance
- Match app theme (dark/light)

### 7. Header Integration
**Modify File:** `covenantrix-desktop/src/components/layout/Header.tsx`
- Import NotificationModal, useNotifications hook
- Add state: `const [isNotificationModalOpen, setIsNotificationModalOpen] = useState(false)`
- Get unreadCount from useNotifications hook
- Modify bell button (line 41-43):
  - Add onClick handler: `() => setIsNotificationModalOpen(true)`
  - Add badge: Conditional render red dot/count badge if unreadCount > 0
  - Badge styling: Absolute positioned, top-right of bell icon
- Render NotificationModal with isOpen and onClose props

### 8. App Provider Hierarchy
**Modify File:** `covenantrix-desktop/src/App.tsx`
- Import NotificationProvider
- Wrap existing providers with NotificationProvider as outermost (or just above SettingsProvider)
- Order: `<NotificationProvider><SettingsProvider>...</SettingsProvider></NotificationProvider>`

---

## IPC Bridge Implementation

### 1. Preload API Exposure
**Modify File:** `covenantrix-desktop/electron/preload.js`
- Add to electronAPI object:
  ```
  notifications: {
    getAll: () => ipcRenderer.invoke('notifications:getAll'),
    getUnreadCount: () => ipcRenderer.invoke('notifications:getUnreadCount'),
    markAsRead: (id) => ipcRenderer.invoke('notifications:markAsRead', id),
    dismiss: (id) => ipcRenderer.invoke('notifications:dismiss', id),
    cleanup: () => ipcRenderer.invoke('notifications:cleanup')
  }
  ```

### 2. IPC Handlers Registration
**Modify File:** `covenantrix-desktop/electron/ipc-handlers.js`
- Add `registerNotificationHandlers(getMainWindow)` function following existing `registerFileHandlers` pattern
- Handler implementations:
  - `notifications:getAll` - Fetch from `${backendUrl}/api/notifications`, return data
  - `notifications:getUnreadCount` - Fetch from `${backendUrl}/api/notifications/unread-count`, return count
  - `notifications:markAsRead` - PUT to `${backendUrl}/api/notifications/${id}/read`
  - `notifications:dismiss` - DELETE to `${backendUrl}/api/notifications/${id}`
  - `notifications:cleanup` - POST to `${backendUrl}/api/notifications/cleanup`
- Use `global.backendUrl` for dynamic backend URL resolution
- HTTP client: Node.js native `fetch` (available in Node 18+), fallback wrapper if needed
- Error handling: Try/catch with log.error, return `{success: false, error: message}` on failure
- Export `registerNotificationHandlers` from module

### 3. Handler Registration in Main
**Modify File:** `covenantrix-desktop/electron/main.js`
- Import registerNotificationHandlers from ipc-handlers
- In `app.whenReady()` handler (line 219-248), after `registerFileHandlers(getMainWindow)` call
- Add: `registerNotificationHandlers(getMainWindow)`

### 4. HTTP Client for Electron Main Process
**Implementation Strategy:**
- Node.js 18+ has native fetch support (already in your environment based on async/await patterns)
- Use native fetch directly in ipc-handlers.js: `const response = await fetch(url, options)`
- No need for electron-fetch or node-fetch if Node 18+
- Fallback: If fetch unavailable, add simple axios import as it's likely already in dependencies for Electron
- Check package.json for existing HTTP client dependencies first

---

## Styling

### 1. Notification Styles
**New File:** `covenantrix-desktop/src/styles/notifications.css`
- Modal overlay classes (reuse/extend from SettingsModal pattern)
- Notification card: Base card, collapsed state, expanded state
- Unread indicator: Bold title, subtle background highlight
- Red dot badge: Absolute positioned, 8px circle, red-500 bg, white border
- Count badge: Similar to red dot but with text, min-width 18px
- Action buttons: Primary (blue-600) and secondary (gray) variants
- Smooth transitions: Expand/collapse animation (max-height or height transition)
- Dark/light theme support: Use CSS variables or Tailwind dark: prefix
- Import in App.tsx or main.tsx

### 2. Badge Component (Optional)
**Consider Creating:** `covenantrix-desktop/src/components/common/Badge.tsx`
- Reusable badge component for red dot/count display
- Props: count (number), variant ('dot' | 'count')
- Can be used in Header bell icon and future features
- Not required if inline styling preferred

---

## Dependencies Review

### Backend
- No new dependencies required
- Uses existing: FastAPI, Pydantic, pathlib, json, datetime, logging

### Frontend
- No new dependencies required
- Uses existing: React, TypeScript, lucide-react (Bell icon), Tailwind CSS
- Date formatting: Implement simple relative time formatter or add date-fns if not already present (check package.json)

### Electron
- HTTP client: Native fetch (Node 18+) or existing axios/node-fetch if already in dependencies
- Check `covenantrix-desktop/package.json` for HTTP client availability

---

## File Structure Summary

```
backend/
â”œâ”€â”€ domain/notifications/
â”‚   â”œâ”€â”€ __init__.py              [NEW]
â”‚   â”œâ”€â”€ models.py                [NEW]
â”‚   â”œâ”€â”€ service.py               [NEW]
â”‚   â””â”€â”€ exceptions.py            [NEW]
â”œâ”€â”€ infrastructure/storage/
â”‚   â””â”€â”€ notification_storage.py  [NEW]
â”œâ”€â”€ api/routes/
â”‚   â””â”€â”€ notifications.py         [NEW]
â”œâ”€â”€ api/schemas/
â”‚   â””â”€â”€ notifications.py         [NEW]
â”œâ”€â”€ core/
â”‚   â””â”€â”€ dependencies.py          [MODIFY - add notification dependencies]
â””â”€â”€ main.py                      [MODIFY - register router, add cleanup on startup]

covenantrix-desktop/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â””â”€â”€ notification.ts      [NEW]
â”‚   â”œâ”€â”€ contexts/
â”‚   â”‚   â””â”€â”€ NotificationContext.tsx [NEW]
â”‚   â”œâ”€â”€ services/api/
â”‚   â”‚   â””â”€â”€ notificationService.ts [NEW]
â”‚   â”œâ”€â”€ features/notifications/
â”‚   â”‚   â”œâ”€â”€ NotificationModal.tsx [NEW]
â”‚   â”‚   â”œâ”€â”€ NotificationCard.tsx  [NEW]
â”‚   â”‚   â””â”€â”€ EmptyState.tsx        [NEW]
â”‚   â”œâ”€â”€ components/layout/
â”‚   â”‚   â””â”€â”€ Header.tsx           [MODIFY - add bell click handler, badge, modal]
â”‚   â”œâ”€â”€ styles/
â”‚   â”‚   â””â”€â”€ notifications.css    [NEW]
â”‚   â””â”€â”€ App.tsx                  [MODIFY - wrap with NotificationProvider]
â””â”€â”€ electron/
    â”œâ”€â”€ preload.js               [MODIFY - add notifications IPC API]
    â”œâ”€â”€ ipc-handlers.js          [MODIFY - add registerNotificationHandlers]
    â””â”€â”€ main.js                  [MODIFY - call registerNotificationHandlers]
```

---

## Implementation Notes

### Deduplication Algorithm
1. When creating notification, check if metadata.dedup_key exists
2. If yes, call storage.find_by_metadata('dedup_key', value)
3. If found and not dismissed, return existing notification (don't create new)
4. If not found or dismissed, create new notification normally

### Cleanup Trigger
1. On backend startup (main.py @app.on_event("startup"))
2. Calculate cutoff_date = datetime.now() - timedelta(days=7)
3. Call notification_service.cleanup_expired(cutoff_date)
4. Log deleted count

### HTTP Client Resolution
1. Check if native fetch available: `typeof fetch !== 'undefined'`
2. If yes, use native fetch
3. If no, check for axios in package.json
4. Use axios as fallback with adapter for fetch-like API

### Backend URL Resolution
- All IPC handlers use `global.backendUrl || 'http://localhost:8080'` for backend communication
- main.js sets global.backendUrl after backend startup (line 126)
- Ensures dynamic port support if backend uses different port

### Error Handling Strategy
- Backend: Raise specific exceptions (NotificationNotFoundError, etc)
- API: Catch exceptions, return HTTPException with appropriate status codes
- Frontend: Try/catch in service methods, return error objects
- IPC: Catch errors, log, return `{success: false, error: message}`
- No dual code paths: Single implementation with error handling in catch blocks

---

## Phase 1 Completion Criteria

1. Backend API endpoints respond with empty arrays/zero counts
2. Frontend displays empty state when no notifications
3. Bell icon in header clickable and opens modal
4. Modal opens/closes correctly
5. IPC bridge communication established (verified with empty data)
6. No console errors
7. Dark/light theme support works
8. Cleanup runs on backend startup (verified in logs)
9. POST /api/notifications endpoint functional (tested with manual API call)
10. No existing functionality broken

Phase 2 will utilize this infrastructure to create actual update notifications.

