# Tier Transition Flows - Simplified JWT Approach

## Design Principle

**JWT validates tier only. TIER_LIMITS defines all features.**

- JWT payload: `{tier, issued, expiry, license_id}`
- NO features in JWT
- Limits pulled from `TIER_LIMITS[tier]` config
- Single source of truth for all tier limits

---

## Tier Transition Matrix

| From | To | Trigger | JWT Required? | Generated By |
|------|----|---------|--------------|--------------| 
| New Install | Trial | First launch | ‚ùå No | System (default) |
| Trial | Paid | User purchases | ‚úÖ Yes | You (via payment) |
| Trial | Free | 7 days expire | ‚ùå No | System (auto) |
| Paid | Paid_Limited | Expiry date reached | ‚ùå No | System (auto) |
| Paid_Limited | Free | 7 days expire | ‚ùå No | System (auto) |
| Paid_Limited | Paid | Payment resolved | ‚úÖ Yes | You (via payment) |
| Free | Paid | User purchases | ‚úÖ Yes | You (via payment) |

---

## User Story 1: New User ‚Üí Trial

**Trigger:** First app launch

**Flow:**
1. App starts, no settings file exists
2. Backend migration creates subscription section
3. System sets tier = "trial"
4. System sets trial_started_at = now
5. System sets trial_expires_at = now + 7 days
6. No JWT needed - trial is default tier

**Storage:**
```json
{
  "subscription": {
    "tier": "trial",
    "license_key": null,
    "trial_started_at": "2025-10-19T10:00:00Z",
    "trial_expires_at": "2025-10-26T10:00:00Z"
  }
}
```

**User Experience:**
- 3 documents max
- Unlimited queries
- Default API keys enabled
- Trial banner shows: "6 days remaining"

---

## User Story 2: Trial ‚Üí Paid (Purchase)

**Trigger:** User buys license

**JWT You Generate & Email:**
```json
{
  "tier": "paid",
  "issued": 1729334400000,
  "expiry": 1760870400000,  // 1 year from purchase
  "license_id": "550e8400-e29b-41d4-a716-446655440000"
}
```

**Encoded JWT (what user receives):**
```
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0aWVyIjoicGFpZCIsImlzc3VlZCI6MTcyOTMzNDQwMDAwMCwiZXhwaXJ5IjoxNzYwODcwNDAwMDAwLCJsaWNlbnNlX2lkIjoiNTUwZTg0MDAtZTI5Yi00MWQ0LWE3MTYtNDQ2NjU1NDQwMDAwIn0...
```

**User Flow:**
1. User receives email: "Your Premium License Key"
2. User opens Settings ‚Üí Subscription ‚Üí Activate License
3. User pastes JWT and clicks Activate
4. Backend validates JWT signature (RS256)
5. Backend extracts tier = "paid"
6. Backend saves tier + license_key to storage
7. Backend clears trial dates
8. Backend looks up limits from TIER_LIMITS["paid"]
9. Notification: "üéâ Welcome to Premium!"

**Storage After:**
```json
{
  "subscription": {
    "tier": "paid",
    "license_key": "eyJhbGci...",
    "trial_started_at": null,
    "trial_expires_at": null,
    "grace_period_started_at": null,
    "grace_period_expires_at": null
  }
}
```

**User Experience:**
- Unlimited documents
- Unlimited queries
- 100MB max file size
- Default API keys enabled

---

## User Story 3: Trial ‚Üí Free (Expiry)

**Trigger:** 7 days pass, app startup

**Flow:**
1. User opens app on day 8
2. Backend loads settings
3. Backend checks: trial_expires_at < now() ‚Üí TRUE
4. Backend transitions tier = "trial" ‚Üí "free"
5. Backend clears trial dates
6. Backend forces api_keys.mode = "custom"
7. Backend saves settings
8. Notification: "Trial ended. Configure your API keys in Settings."

**Storage After:**
```json
{
  "subscription": {
    "tier": "free",
    "license_key": null,
    "trial_started_at": null,
    "trial_expires_at": null
  }
}
```

**User Experience:**
- 3 documents max
- 50 queries/month + 20/day limits
- Must use custom API keys
- Upgrade prompt in UI

---

## User Story 4: Paid ‚Üí Paid_Limited (Expiry)

**Trigger:** Paid JWT expires, app startup detects it

**‚ö†Ô∏è CRITICAL DESIGN DECISION:**

**Option A (RECOMMENDED): Auto-Downgrade to Paid_Limited**
- System automatically creates 7-day grace period
- No new JWT required
- User notified in-app
- Payment must be resolved within 7 days

**Option B: Hard Cutoff**
- Paid JWT expires ‚Üí immediately downgrade to Free
- No grace period
- User must repurchase

**We recommend Option A for better UX.**

**Flow (Option A):**
1. User opens app after paid JWT expires
2. Backend loads settings
3. Backend validates license_key JWT
4. JWT validation fails: expiry < now()
5. Backend transitions tier = "paid" ‚Üí "paid_limited"
6. Backend sets grace_period_started_at = now
7. Backend sets grace_period_expires_at = now + 7 days
8. Backend invalidates/removes expired license_key
9. Backend applies TIER_LIMITS["paid_limited"]
10. Notification: "‚ö†Ô∏è License expired. 7-day grace period started."

**Storage After:**
```json
{
  "subscription": {
    "tier": "paid_limited",
    "license_key": null,  // Expired JWT removed
    "grace_period_started_at": "2025-10-19T10:00:00Z",
    "grace_period_expires_at": "2025-10-26T10:00:00Z"
  }
}
```

**User Experience:**
- First 3 documents visible only (others hidden)
- 50 queries/month + 20/day limits
- Must use custom API keys
- Grace period banner: "6 days to renew"
- Upgrade prompt in UI

**Key Point:** User doesn't manually enter anything. System auto-downgrades on expiry detection.

---

## User Story 5: Paid_Limited ‚Üí Free (Grace Expires)

**Trigger:** 7 days pass, app startup

**Flow:**
1. User opens app after grace period
2. Backend checks: grace_period_expires_at < now() ‚Üí TRUE
3. Backend transitions tier = "paid_limited" ‚Üí "free"
4. Backend deletes documents beyond first 3 (hard delete)
5. Backend updates usage_tracker document count
6. Backend clears grace period dates
7. Notification: "Grace period ended. Upgrade to restore access."

**Storage After:**
```json
{
  "subscription": {
    "tier": "free",
    "license_key": null,
    "grace_period_started_at": null,
    "grace_period_expires_at": null
  }
}
```

**User Experience:**
- 3 documents max (extras deleted)
- 50 queries/month + 20/day limits
- Must use custom API keys
- Upgrade prompt in UI

---

## User Story 6: Paid_Limited ‚Üí Paid (Renewal)

**Trigger:** User renews/purchases new license

**JWT You Generate & Email:**
```json
{
  "tier": "paid",
  "issued": 1729939200000,  // Now
  "expiry": 1761475200000,  // 1 year from now
  "license_id": "550e8400-e29b-41d4-a716-446655440000"  // Same or new ID
}
```

**User Flow:**
1. User receives renewal email with new JWT
2. User opens Settings ‚Üí Subscription ‚Üí Activate License
3. User pastes JWT and clicks Activate
4. Backend validates JWT
5. Backend extracts tier = "paid"
6. Backend saves new license_key
7. Backend clears grace period dates
8. Backend restores all document visibility
9. Notification: "Welcome back! Full access restored."

**Storage After:**
```json
{
  "subscription": {
    "tier": "paid",
    "license_key": "eyJhbGci...",  // New JWT
    "grace_period_started_at": null,
    "grace_period_expires_at": null
  }
}
```

**User Experience:**
- All documents visible again
- Unlimited queries restored
- Default API keys re-enabled

---

## User Story 7: Free ‚Üí Paid (Purchase)

**Trigger:** Free user decides to upgrade

**Flow:** Same as Trial ‚Üí Paid (Story 2)

---

## JWT Structure Reference

**Minimal JWT Payload (Your Implementation):**
```json
{
  "tier": "paid",                    // trial | free | paid | paid_limited
  "issued": 1729334400000,           // Unix timestamp (ms)
  "expiry": 1760870400000,           // Unix timestamp (ms)
  "license_id": "uuid-v4-string"     // Unique identifier
}
```

**What's NOT in JWT:**
- ‚ùå max_documents
- ‚ùå max_queries_monthly
- ‚ùå max_doc_size_mb
- ‚ùå use_default_keys
- ‚ùå Any feature flags

**Why:** Features are defined in `TIER_LIMITS[tier]` config, not in JWT.

---

## System Architecture Changes Needed

### 1. Remove Features from JWT Payload
**File:** `backend/domain/subscription/license_validator.py`
- Remove feature extraction logic
- Only extract: tier, issued, expiry, license_id

### 2. Simplify get_tier_features()
**File:** `backend/domain/subscription/tier_config.py`
```python
def get_tier_features(tier: str) -> Dict[str, Any]:
    """Get tier features from config only"""
    if tier not in TIER_LIMITS:
        raise ValueError(f"Invalid tier: {tier}")
    return TIER_LIMITS[tier]
```
- Remove `jwt_features` parameter
- No override logic

### 3. Remove Features from Storage (Optional)
**File:** `backend/api/schemas/settings.py`

Option A: Remove entirely
```python
class SubscriptionSettings(BaseModel):
    tier: str
    license_key: Optional[str]
    trial_started_at: Optional[str]
    trial_expires_at: Optional[str]
    grace_period_started_at: Optional[str]
    grace_period_expires_at: Optional[str]
    # NO features field
```

Option B: Keep as computed property (recommended for caching)
```python
@property
def features(self) -> FeatureFlags:
    """Computed from tier"""
    return FeatureFlags(**get_tier_features(self.tier))
```

### 4. Update activate_license()
**File:** `backend/domain/subscription/service.py`
- Extract only tier from JWT
- Look up features from TIER_LIMITS
- Don't store features (or compute on-demand)

---

## Payment Integration Points

### When You Generate JWTs:

**Initial Purchase (Trial/Free ‚Üí Paid):**
```python
jwt_payload = {
    "tier": "paid",
    "issued": int(time.time() * 1000),
    "expiry": int((time.time() + 31536000) * 1000),  # 1 year
    "license_id": str(uuid.uuid4())
}
```

**Renewal (Paid_Limited ‚Üí Paid):**
```python
jwt_payload = {
    "tier": "paid",
    "issued": int(time.time() * 1000),
    "expiry": int((time.time() + 31536000) * 1000),  # 1 year
    "license_id": existing_license_id  # Reuse or new
}
```

### When User's Payment Fails:
- Do nothing
- App detects JWT expiry automatically
- System auto-transitions to paid_limited
- No email or manual action needed

### Subscription Status Check:
You may want periodic validation:
```
GET https://your-api.com/validate-license
Headers: Authorization: Bearer <jwt>
Response: {valid: true, tier: "paid", days_remaining: 45}
```

---

## Benefits of This Approach

‚úÖ **Single Source of Truth:** TIER_LIMITS defines everything  
‚úÖ **No JWT Abuse:** Can't forge custom limits  
‚úÖ **Better UX:** No manual downgrade required  
‚úÖ **Simpler Code:** Less complexity in validation  
‚úÖ **SaaS Standard:** Tier determines features, not tokens  
‚úÖ **Easy Updates:** Change limits in config, affects all users  
‚úÖ **Grace Period UX:** 7-day buffer before hard downgrade  

---

## Edge Cases Handled

**Expired JWT in storage:**
- Detected on app startup
- Auto-transitions to paid_limited (if from paid)
- Auto-transitions to free (if from trial)

**Invalid JWT signature:**
- Treated as no license
- User stays on current tier or downgrades

**Manual JSON editing:**
- Features recomputed from tier on every load
- Can't fake higher tier without valid JWT

**Clock skew:**
- Use server time for issued/expiry timestamps
- Client validates but doesn't trust local time

---

## Open Questions

1. **Renewal reminder:** Email users before paid JWT expires?
2. **License transfer:** Can users move license to new device?
3. **Offline grace period:** How long can app run offline before requiring validation?
4. **Subscription portal:** Will users manage billing on your website?

---

## UI Impact Analysis & Implementation Safety

### ‚ö†Ô∏è CRITICAL: Components That Reference subscription.features

Based on codebase analysis, these UI areas currently access `subscription.features`:

#### 1. **SubscriptionContext.tsx** - NEEDS UPDATE
**Current Code:**
```typescript
const { max_documents } = subscription.features;
const { max_queries_monthly, max_queries_daily } = subscription.features;
```

**Issue:** Context reads features from stored subscription object  
**Impact:** Will break if features field removed from storage  
**Fix Required:** ‚úÖ YES - Compute features from TIER_LIMITS[tier]

**Implementation:**
```typescript
// BEFORE: subscription.features.max_documents
// AFTER: getTierLimits(subscription.tier).max_documents

const getTierLimits = (tier: string) => {
  // Call backend API or import tier config
  return TIER_LIMITS[tier];
};
```

---

#### 2. **SubscriptionTab.tsx** - NEEDS UPDATE
**Current Code:**
```typescript
<div>Documents: {usage?.documents_uploaded} / {subscription?.features.max_documents === -1 ? '‚àû' : subscription?.features.max_documents}</div>
<div>Queries (Monthly): {usage?.queries_this_month} / {subscription?.features.max_queries_monthly === -1 ? '‚àû' : subscription?.features.max_queries_monthly}</div>
```

**Issue:** UI displays features from subscription object  
**Impact:** Will show undefined if features removed  
**Fix Required:** ‚úÖ YES - Compute limits from tier

**Implementation:**
```typescript
const limits = getTierLimits(subscription.tier);
<div>Documents: {usage?.documents_uploaded} / {limits.max_documents === -1 ? '‚àû' : limits.max_documents}</div>
```

---

#### 3. **useUpload.ts Hook** - NEEDS UPDATE
**Current Code:**
```typescript
const fileSizeMB = file.size / (1024 * 1024);
if (fileSizeMB > subscription?.features.max_doc_size_mb) {
  showError(`File too large. Maximum size: ${subscription?.features.max_doc_size_mb}MB`);
  return;
}
```

**Issue:** Validates file size against features  
**Impact:** Upload validation breaks  
**Fix Required:** ‚úÖ YES - Get limits from tier

---

#### 4. **Backend API Responses** - SAFE ‚úÖ
**Current Code:**
```python
# GET /api/subscription/status returns:
{
  "tier": "trial",
  "features": {...},  # Currently included
  "usage": {...}
}
```

**Issue:** Frontend expects features in API response  
**Impact:** Frontend will receive undefined features  
**Fix Required:** ‚úÖ YES - Backend must compute and return features

**Backend Safety:**
```python
# In SubscriptionService.get_current_subscription_async()
subscription = await self.settings_storage.load_settings()
tier = subscription.subscription.tier

# Compute features from TIER_LIMITS
computed_features = get_tier_features(tier)

# Return with computed features
return {
    "tier": tier,
    "features": computed_features,  # Always computed, never stored
    "usage": usage_data
}
```

---

### ‚úÖ SAFE: No Changes Needed

These areas are **NOT affected** by removing features from storage:

#### 1. **Document Upload/Query Endpoints** - SAFE ‚úÖ
Backend already computes limits from `TIER_LIMITS[tier]` in enforcement logic.

**File:** `backend/api/routes/documents.py`
```python
# Uses SubscriptionService.check_upload_allowed()
# Which internally uses get_tier_features(tier)
```

**No UI changes needed** - enforcement happens server-side.

---

#### 2. **Trial Banner / Grace Period Warning** - SAFE ‚úÖ
These components only check `subscription.tier` and expiry dates.

**Files:**
- `TrialBanner.tsx` - Only reads `subscription.tier` and `trial_expires_at`
- `GracePeriodWarning.tsx` - Only reads `subscription.tier` and `grace_period_expires_at`

**No changes needed** - don't reference features.

---

#### 3. **Document List / Analytics** - SAFE ‚úÖ
These use usage stats from `usage_tracking.json`, not features.

**No changes needed** - don't reference features.

---

### üîß Implementation Checklist

#### Phase 1: Backend Changes (Breaking Changes)
- [ ] Remove `features` field from `SubscriptionSettings` Pydantic model
- [ ] Update `get_tier_features()` to remove `jwt_features` parameter
- [ ] Update `activate_license()` to NOT extract features from JWT
- [ ] Ensure `/api/subscription/status` computes features on-the-fly from tier
- [ ] Update all internal service methods to compute features from `TIER_LIMITS[tier]`

#### Phase 2: Frontend Changes (Dependent on Backend)
- [ ] Update `SubscriptionContext` to compute features instead of reading from storage
- [ ] Update `SubscriptionTab` to call `getTierLimits(tier)` instead of `subscription.features`
- [ ] Update `useUpload` hook to get limits from context's computed features
- [ ] Add TypeScript helper: `getTierLimits(tier: string): FeatureFlags`
- [ ] Update API response interfaces to reflect computed features

#### Phase 3: Testing
- [ ] Test trial ‚Üí paid transition (features should match new tier)
- [ ] Test document upload with file size limits (should still enforce)
- [ ] Test query limits (should still enforce)
- [ ] Test SubscriptionTab display (should show correct limits)
- [ ] Test that manual JSON editing doesn't allow fake limits

---

### üõ°Ô∏è Safety Implementation Notes

#### Critical: API Response Structure Must Stay Compatible
**Current Response (works with UI):**
```json
{
  "tier": "paid",
  "features": {
    "max_documents": -1,
    "max_queries_monthly": -1,
    ...
  },
  "usage": {...}
}
```

**After Change (must maintain same structure):**
```json
{
  "tier": "paid",
  "features": {  // ‚úÖ Still included, just computed not stored
    "max_documents": -1,
    "max_queries_monthly": -1,
    ...
  },
  "usage": {...}
}
```

**Why:** Frontend expects `response.data.subscription.features` in multiple places.

---

#### Backend Endpoint Safety Pattern
Every endpoint that returns subscription data must compute features:

```python
@router.get("/subscription/status")
async def get_subscription_status(
    subscription_service: SubscriptionService = Depends(get_subscription_service)
):
    subscription = await subscription_service.get_current_subscription_async()
    
    # ‚úÖ CRITICAL: Compute features from tier
    computed_features = get_tier_features(subscription.tier)
    
    return {
        "tier": subscription.tier,
        "features": computed_features,  # Always fresh
        "license_key": subscription.license_key,
        "trial_started_at": subscription.trial_started_at,
        # ... other fields
    }
```

---

#### Frontend Helper Function Pattern
Add to `SubscriptionContext`:

```typescript
// Helper to get tier limits (client-side copy of TIER_LIMITS)
const TIER_LIMITS = {
  trial: { max_documents: 3, max_doc_size_mb: 10, ... },
  free: { max_documents: 3, max_doc_size_mb: 10, ... },
  paid: { max_documents: -1, max_doc_size_mb: 100, ... },
  paid_limited: { max_documents: 3, max_doc_size_mb: 10, ... }
};

export const getTierLimits = (tier: string): FeatureFlags => {
  return TIER_LIMITS[tier] || TIER_LIMITS.free;
};
```

**Important:** This is a **client-side cache** only. Server is still source of truth.

---

### üìã Migration Path (Zero Downtime)

**Step 1:** Backend keeps returning features in API (computed)  
**Step 2:** Frontend updated to use computed features  
**Step 3:** Remove features from storage (optional - can keep as cache)  
**Step 4:** Verify all enforcement still works

**Rollback Plan:** If issues arise, features in storage can be restored without code changes.

